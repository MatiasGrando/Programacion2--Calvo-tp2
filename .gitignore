#ifndef LISTA_H
#define LISTA_H
#include "Nodo.h"

template <typename T>
class Lista
{
    private:
        Nodo<T>* primero;
        Nodo<T>* ultimo;
        Nodo<T>* cursor;
        unsigned int tamanio;

    public:
       //pre:
       //post: crea una lista vacia 
       Lista();
       //pre:lista creada
       //post: libera la memoria pedida
       ~Lista();
       //pre:lista no vacia
       //post: elemina un elemento de la lista
    
       void eliminarElemento(Nodo<T>* cursor);
       //pre:
       //post: agrega un nodo al final de la lista

       void agregarElemento(T nuevoDato);
       //pre:
       //post: devuelve V si la lista esta vacia

       bool listaVacia();
       //pre:
       //post: devuelve el tamanio de la lista
       
       unsigned int obtenerTamanio();

    //-----------------------------------------
        //pre:lista no vacia
       //post: unicia el cursor en la primera poscision
       void iniciarCursor();
       //pre:cursor inicializado
       //post: develve V si se puede avaanzar
        //     avanza una posicion el cursor
        // en caso contrario devuelve F y no hace nada
       bool avanzarCursor();
       //pre: cursor se haya inicializado
       //post: devuelve un puntero al nodo al q apunta el cursor

       Nodo<T>* obtenerCursor();
};


template <typename T>
Lista<T>::Lista()
{
    primero=0;
    ultimo=0;
    tamanio=0;
    cursor=0;
}
template <typename T>
Lista<T>::~Lista()
{
    while(primero != 0)
    {
        iniciarCursor();
        this->primero= this->primero->obtenerSiguiente();
        delete cursor;
    }
}
template <typename T>
void Lista<T>::iniciarCursor()
{
    this->cursor=this->primero;
}
template <typename T>
bool Lista<T>::avanzarCursor()
{
    this->cursor = this->cursor->obtenerSiguiente();
    return(this->cursor !=0);
}
template <typename T>
void Lista<T>::retrocederCursor()
{
    this->cursor = this->cursor->obtenerAnterior();
}
template <typename T>
Nodo<T>* Lista<T>::obtenerCursor()
{
    return this->cursor;
}
template <typename T>
bool Lista<T>::listaVacia()
{
    return (this->primero==0);
}
template <typename T>
void Lista<T>::agregarElemento(T nuevoDato)
{
    Nodo<T>* nuevoElemento = new Nodo<T>(nuevoDato);
    this->tamanio++;
    if (!listaVacia())
    {
        this->ultimo->cambiarSiguiente(nuevoElemento);
        this->ultimo = nuevoElemento;
    }
    else
    {
        this->primero=nuevoElemento;
        this->ultimo=nuevoElemento;
    }
}
template <typename T>
void Lista<T>::eliminarElemento(Nodo<T>* cursor)
{
    if(cursor->esElUltimo())
    {
        obtenerAnterior(cursor)->cambiarSiguiente(0);
        this->ultimo=obtenerAnterior(cursor);
        delete cursor;
    }
    else if (cursor->esElPrimero())
    {
        obtenerSiguiente(cursor)->cambiarAnterior(0);
        this->primero = obtenerSiguiente(cursor);
        delete cursor;
    }
    else
    {
        obtenerAnterior(cursor)->cambiarSiguiente(obtenerSiguiente(cursor));
        obtenerSiguiente(cursor)->cambiarAnterior(obtenerAnterior(cursor));
        delete cursor;
    }
}
template <typename T>
unsigned int Lista<T>::obtenerTamanio()
{
    return this-> tamanio;
}


#endif // LISTA_H
